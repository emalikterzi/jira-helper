package container

import (
	"github.com/emt/jira-helper/service"
	"github.com/emt/jira-helper/dto"
	"github.com/emt/jira-helper/db"
	"strings"
	"fmt"
	"sync"
	"os"
	"github.com/emt/jira-helper/job"
	"os/exec"
	"strconv"
	"time"
)
//2016-08-12 13:41:08 +0300
const gitTimeFormat = "2006-01-02 15:04:05 -0700";

type JiraAppContainer struct {
	Client     *service.Client
	DbAdaptor  *db.DbAdaptor
	Properties *JiraProperties
}

type JiraProperties struct {
	Jira       struct {
			   Email    string `yaml:"email"`
			   Password string `yaml:"password"`
		   } `yaml:"jira"`
	DbLocation string `yaml:"db"`
	Repos      []string `yaml:"repo"`
	GitAuthor  string `yaml:"author"`
}

func (s *JiraAppContainer) logWork(job job.Job) (bool) {
	comment := fmt.Sprintf("\n%s \n\n#########################\n Auto Generated by Jira-Helper \n#########################\n", job.Comment);
	timeSpent := job.JobValue;

	splitted := (strings.Split(timeSpent, ""));
	timePrefix := splitted[len(splitted) - 1];
	fmt.Println(timeSpent);
	a, _ := strconv.Atoi(strings.Replace(strings.Join(splitted, ""), timePrefix, "", 1))

	switch timePrefix {
	case "m":
		a = a * 60
		break;
	case "h":
		a = a * 60 * 60
	}

	req := &dto.WorkLogRequest{Comment:comment, Started:time.Now().Format(dto.JiraDateFormat), TimeSpentSeconds:a}

	_, err := s.Client.IssueService.WorkLog(req, job.TaskName);
	if (!err) {

	}
	return err;
}

func (s *JiraAppContainer) Init() {

	user := &dto.LoginRequest{
		Username:s.Properties.Jira.Email,
		Password:s.Properties.Jira.Password}

	err := s.Client.AuthService.Login(user);
	if (err != nil) {
		panic(err)
	}

}

func (s *JiraAppContainer) CheckCommits() {
	for _, repoPath := range s.Properties.Repos {

		//repo klasorunden son kisim alinir
		repoName := splitFolderGetLast(repoPath);

		//repo db de var mi diye kontrol edilir
		repo := s.DbAdaptor.GetRepo(repoName);


		wg := new(sync.WaitGroup)
		wg.Add(1)

		//commitlere gore tum joblari olusturur
		jobs := getAllJobs(repoPath, s.Properties.GitAuthor, wg)

		wg.Wait();
		if (len(jobs) > 0) {

			var LastDateFromDb time.Time;

			// joblar icindeki karsilastirma
			isPersist := false;
			var LastJob job.Job;
			var LastDate time.Time;


			if (repo != nil) {
				parsed, _ := time.Parse(gitTimeFormat, repo.LastCommit);
				LastDateFromDb = parsed;
			} else {
				// db den son islem tarihi alinamadigi icin min date joblar icinden secilir
				for index, job := range jobs {
					if (index == 0) {
						LastJob = job;
						LastDate = job.JobDate.Add(-10 * time.Minute);
						continue;
					}
					if (job.JobDate.Before(LastDate)) {
						LastJob = job;
						LastDate = job.JobDate;
					}
				}
				LastDateFromDb = LastDate;
			}

			for _, job := range jobs {
				if (job == LastJob || job.JobDate.After(LastDateFromDb)) {
					if (s.logWork(job)) {
						if (job.JobDate.After(LastDate)) {
							LastDate = job.JobDate;
							LastJob = job;
							isPersist = true;
						}
					}

				}
			}

			if (isPersist) {
				s.DbAdaptor.UpdateRepo(repoName, LastJob.JobDateStr)
			}

		}
	}
}
func getAllJobs(repoName string, author string, wg *sync.WaitGroup) ([]job.Job) {

	os.Chdir(repoName);
	totalJobs := make([]job.Job, 0);
	byteOut, err := exe_cmd("git log --date=default --pretty=format:%ai_SPLITTER_%s --author=" + author, wg);
	if (err == nil) {
		a := strings.Split(string(byteOut), "\n");
		for _, SingleCommit := range a {

			CommitJobs := CommentProcess(SingleCommit);
			if (CommitJobs != nil && len(CommitJobs) > 0) {
				for _, job := range CommitJobs {
					totalJobs = append(totalJobs, job);
				}

			}

		}
	}
	return totalJobs;
}

func splitFolderGetLast(folder string) (string) {
	a := strings.Split(folder, "/");
	return a[len(a) - 1];
}

func CommentProcess(SingleCommit string) ([]job.Job) {

	SplittedCommit := strings.Split(SingleCommit, "_SPLITTER_");

	CommitComment := SplittedCommit[1];
	CommitDateStr := SplittedCommit[0];
	CommitDate, err := time.Parse(gitTimeFormat, CommitDateStr);

	if (err != nil) {
		panic(err);
	}
	taskName, err := job.IsJobExist(CommitComment);

	if (taskName == "") {
		return nil;
	}

	returnJobs := make([]job.Job, 0)

	workLogJob := job.FindWorkLogJob(CommitComment)

	///todo bu igrenc seyleri duzelt
	CommitComment = strings.TrimSpace(strings.Split(strings.Replace(CommitComment, taskName, "", 1), "#")[0])
	taskName = strings.Replace(taskName, "[", "", 1)
	taskName = strings.Replace(taskName, "]", "", 1)

	if (workLogJob != nil) {
		workLogJob.JobDate = CommitDate;
		workLogJob.JobDateStr = CommitDateStr;
		workLogJob.TaskName = taskName;
		workLogJob.Comment = CommitComment;
		returnJobs = append(returnJobs, *workLogJob);
	}
	return returnJobs;
}

func exe_cmd(cmd string, wg *sync.WaitGroup) ([]byte, error) {
	parts := strings.Fields(cmd)

	head := parts[0]
	parts = parts[1:len(parts)]

	out, err := exec.Command(head, parts...).Output()
	wg.Done()
	return out, err;
}



