package container

import (
	"github.com/emt/jira-helper/service"
	"github.com/emt/jira-helper/dto"
	"github.com/emt/jira-helper/db"
	"strings"
	"fmt"
	"sync"
	"os"
	"github.com/emt/jira-helper/job"
	"os/exec"
	"regexp"
	"strconv"
	"time"
)

const gitTimeFormat = "Mon Jan 1 15:04:05 2006 -0700";

type JiraAppContainer struct {
	Client     *service.Client
	DbAdaptor  *db.DbAdaptor
	Properties *JiraProperties
}

type JiraProperties struct {
	Jira       struct {
			   Email    string `yaml:"email"`
			   Password string `yaml:"password"`
		   } `yaml:"jira"`
	DbLocation string `yaml:"db"`
	Repos      []string `yaml:"repo"`
	GitAuthor  string `yaml:"author"`
}

func (s *JiraAppContainer) logWork(job job.Job) (bool) {
	fmt.Printf("Loging %s\n", job);
	comment := fmt.Sprintf("\n%s \n\n#########################\n Auto Generated by Jira-Helper \n#########################\n", job.Comment);
	timeSpent := job.JobValue;

	fmt.Println(comment)
	splitted := (strings.Split(timeSpent, ""));
	timePrefix := splitted[len(splitted) - 1];

	a, _ := strconv.Atoi(strings.Replace(strings.Join(splitted, ""), timePrefix, "", 1))

	switch timePrefix {
	case "m":
		a = 60 * 15
		break;
	case "h":
		a = a * 60 * 60
	}

	req := &dto.WorkLogRequest{Comment:comment, Started:time.Now().Format(dto.JiraDateFormat), TimeSpentSeconds:a}

	_, err := s.Client.IssueService.WorkLog(req, job.TaskName);
	if (!err) {
		fmt.Println("Logging error")
	}
	return err;
}

func (s *JiraAppContainer) Init() {

	user := &dto.LoginRequest{
		Username:s.Properties.Jira.Email,
		Password:s.Properties.Jira.Password}

	err := s.Client.AuthService.Login(user);
	if (err != nil) {
		panic(err)
	}

}

func (s *JiraAppContainer) Engage() {
	for _, element := range s.Properties.Repos {

		//repo klasorunden son kisim alinir
		repoName := splitFolderGetLast(element);

		//repo db de var mi diye kontrol edilir
		repo := s.DbAdaptor.GetRepo(repoName);


		var lastCommitDate time.Time
		var lastDateStr string
		var dateFlag = false;

		if (repo != nil) {
			dateFlag = true;
			date, _ := time.Parse(gitTimeFormat, repo.LastCommit);
			lastCommitDate = date;
			lastDateStr = repo.LastCommit;
		}


		//ilgili reponin commit logu controler edilir
		wg := new(sync.WaitGroup)
		wg.Add(1)

		os.Chdir(element);
		byteOut, err := exe_cmd("git log --date=default --pretty=format:%ad_SPLITTER_%s --author=" + s.Properties.GitAuthor, wg);
		if (err == nil) {
			a := strings.Split(string(byteOut), "\n");
			for _, element := range a {
				commit := strings.Split(element, "_SPLITTER_");


				comment := commit[1];

				jobs := commentProcess(comment);
				if (len(jobs) > 0) {
					date := commit[0];
					currentCommitDate, _ := time.Parse(gitTimeFormat, date);

					for _, element := range jobs {
						if (dateFlag) {
							switch element.JobType {
							case "log":
								if (currentCommitDate.After(lastCommitDate)) {
									if (s.logWork(element)) {
										fmt.Println("repo" + date)
										lastDateStr = date;
									}

								}
								break;
							}
						} else {
							switch element.JobType {
							case "log":
								if (s.logWork(element)) {
									fmt.Println("repos" + date)
									lastDateStr = date;
									// ilk yazilacak lanet dateden dolayi
									calcuatedDate, _ := time.Parse(gitTimeFormat, date);
									lastCommitDate = calcuatedDate;
									dateFlag = true;
								}
								break;
							}

						}
						s.DbAdaptor.UpdateRepo(repoName, lastDateStr);
					}
				}
			}
			fmt.Println("Repo %s updated date %s", repoName, lastDateStr);
		}
		wg.Wait();
	}
}

func splitFolderGetLast(folder string) (string) {
	a := strings.Split(folder, "/");
	return a[len(a) - 1];
}

func commentProcess(comment string) ([]job.Job) {
	if (!strings.Contains(comment, "#jira") ) {
		return nil;
	}

	r, _ := regexp.Compile("\\[[\\w]+-[\\w\\d]+\\]");
	tasks := r.FindStringSubmatch(comment);

	if (len(tasks) == 0) {
		return nil;
	}

	taskName := tasks[0];

	commentWithoutTask := strings.TrimSpace(strings.Split(comment, taskName)[1]);
	jiraTasks := strings.Split(strings.TrimSpace(strings.Split(commentWithoutTask, "#jira;")[1]), ";");


	commentWithoutTask = strings.TrimSpace(strings.Split(commentWithoutTask, "#jira;")[0]);

	returnJobs := make([]job.Job, 1)

	taskName = strings.Replace(taskName, "[", "", 1);
	taskName = strings.Replace(taskName, "]", "", 1);

	//fmt.Println(len(jiraTasks))
	for index, element := range jiraTasks {
		jobName := strings.Split(element, "=")[0];
		jobValue := strings.Split(element, "=")[1];
		switch jobName {
		case "log":
			returnJobs[index] = *(&job.Job{JobType:jobName, TaskName:taskName, JobValue:jobValue, Comment:commentWithoutTask})
		}

	}

	return returnJobs;
}

func exe_cmd(cmd string, wg *sync.WaitGroup) ([]byte, error) {
	parts := strings.Fields(cmd)

	head := parts[0]
	parts = parts[1:len(parts)]

	out, err := exec.Command(head, parts...).Output()
	wg.Done()
	return out, err;
}



